---
title: 'Homework 1'
author: "2015122057 최종문"
date: "1 April 2020"
output:
  word_document: default
  html_document:
    df_print: paged
  pdf_document:
    fig_caption: yes
    latex_engine: xelatex
geometry: margin=1in
header-includes: \usepackage{graphics,graphicx} \usepackage{longtable} \usepackage{hyperref}
  \usepackage{wrapfig} \usepackage{amsmath,verbatim,amssymb,epsfig,color,lscape} \usepackage{fancyhdr}
  \usepackage{natbib} \usepackage{lastpage} \usepackage{multirow} \usepackage[normalem]{ulem}
  \usepackage{bm}
mainfont: NanumGothic
fontsize: 10pt
subtitle: Exploratory Data Analysis
classoption: a4paper
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(tinytex.verbose = TRUE)
```
<br><br>

#### **1. EDA의 네 가지 주제에 대하여 설명하라. 한 주제당 3줄 이하.**
* **현시성(Revelation)**<br>
자료 안에 숨겨진 정보를 가장 쉽게 파악할 수 있는 방법은 자료를 시각화하는 것이다. 정보를 한눈에 파악하여 수학과 통계에 익숙하지 않은 비전문가들도 쉽게 자료를 이해할 수 있다는 장점이 있다. 또한 그래프를 통해 얻은 인사이트를 자료 분석에 활용할 수 있다. EDA에서는 자료에 따라 다양한 그래프 작성 기법들이 사용된다. 
<br><br>
* **잔차(Residual)**<br>
잔차는 각 개별 값들이 주 경향(main trend)로부터 얼마나 벗어났는지를 알려주는 수치이다. 일반적인 회귀분석의 목적은 최적의 회귀선을 찾아내어 각 설명변수의 영향력을 측정하고 종속변수를 예측하는 것이다. 하지만 EDA에서는 회귀선에서 크게 벗어나는 각 개별 잔차들도 유용한 통계적 정보를 갖고 있으므로 이를 분석에 활용한다. 
<br><br>
* **재표현(Re-expression)**<br>
자료의 재표현이란 원래의 변수를 적당한 척도로 바꾸는 것을 말한다. 전통적 통계학 용어로는 변환(transformation)이라고 하는데 로그변환, 제곱근변환, 역수변환 등이 있다. 관측된 자료들은 일반적으로 대칭성과 산포의 균일 측면에서 분포가 왜곡되어 있을 가능성이 크다. 자료의 재표현을 통해 자료의 대칭성과 산포의 균일을 확보하고 선형화 등의 이득을 얻을 수 있다. 
<br><br>
* **저항성(Resistance)**<br>
EDA는 특이값이나 자료의 파손에 대해 저항성을 가져야 한다. 저항성이 높다는 것은 새로운 자료의 출현과 기존 자료의 변동에 따른 영향을 적게 받는다는 것이다. 저항성의 관점에서 평균보다 중위수가 더 바람직한 대표값 측도라고 할 수 있다. 실제로 EDA에서는 평균보다 중위수 개념이 더 많이 쓰이고 선호된다. 

<br><br>

#### **2. Ashwan에서 측정한 Nile 강의 유량 자료에 대해 줄기잎그림을 그리고 자료에 대하여 설명하여라.**
R의 패키지는 분석 함수뿐 아니라 예제 데이터도 포함하는 경우가 많다. 이 데이터를 패키지 데이터셋이라고 한다. 보통 R을 시작하면 datasets라고 하는 패키지가 자동으로 로드되는데 이 패키지는 기본적인 예제 데이터셋만을 포함하고 있는 패키지이다.`Nile` 데이터셋은 이 패키지에 포함되어 있기 때문에 `Nile`이라는 명령어로 바로 불러올 수 있다. <br><br>
`Nile` 데이터셋은 1871년부터 1970년까지 아스완에서의 나일강의 연간 유량 흐름을 측정한 시계열자료이다. 자료는 다음과 같다. 
```{r}
Nile
```
먼저, `summary`를 통해 Nile 데이터의 기초통계량을 확인할 수 있다. 최소값은 456, 중앙값은 893.5, 평균은 919.4, 최대값은 1370이다. 
```{r}
summary(Nile)
```

`stem()`이라는 명령어로 위 데이터의 줄기잎그림을 그릴 수 있다. 줄기잎그림(stem-and-leaf plot)은 소규모 자료의 분포적 특성을 살펴보기 위하여 작성되는 그래프이다. 결과는 다음과 같다. 
```{r}
stem(Nile)
```
위의 줄기잎그림에서 줄기는 백의 자리수를, 잎은 십의 자리수를 나타낸다. 각 줄기 내에서 잎들은 크기순으로 정렬되어 있으며 각 잎들은 같은 너비(width)를 가지기 때문에 자료의 분포를 비교하기에 용이하다. 줄기잎그림은 자료의 분포를 시각화한다는 점에서 히스토그램과 비슷하지만 정보의 보전 면에서 유리하고 또한 쉽게 구간(줄기) 수를 늘이거나 줄일 수 있다. <br><br>
우리는 줄기잎그림을 통해 다음과 같은 자료의 특성을 관찰할 수 있다. 

* **군집(cluster)의 수**<br>
위 그림의 주요 특징은 이봉분포의 모습을 보인다는 점이다. 이것은 자료가 2개의 군집으로 되어있음을 말한다. 800대의 주 군집과 1100대의 딸린 군집이 혼합된 형태를 보인다. 각 군집이 어떤 속성과 관련이 있는가를 밝혀보는 작업이 필요해 보인다. 

* **대칭성 여부**<br>
줄기잎그림을 통해 대칭성 여부를 눈으로 확인할 수 있다. 위 그림에서는 800대의 중간 부분에서 가장 높은 빈도를 보이고 양 극단으로 갈수록 빈도 수가 줄어드는 것을 확인할 수 있다. 하지만 위에서 언급했듯이 이봉분포의 형태를 띠고 있기 때문에 대칭적이라고 보기는 힘들다.

* **자료의 범위 및 산포**<br>
자료의 범위 및 산포 역시 쉽게 확인할 수 있다. 자료의 범위는 460부터 1370까지이다.(그림에서 판단할 수 있는 자료의 범위는 460~1370이지만 summary를 확인해보면 원래 자료의 범위는 456~1370이다. 이는 원 자료가 줄기잎그림으로 표현될 때 값들이 일의 자리에서 반올림하여 그려졌기 때문이다.) 하지만 500대에서 자료의 공백이 있기 때문에 400대의 자료를 특이값으로 처리할지에 대한 판단이 필요하다. 또한 산포의 척도는 주로 분산이나 표준편차인데 이를 구하지 않고 눈으로 산포의 정도를 비교할 수 있다. 두 개의 자료에 대한 줄기잎그림을 옆에 놓고 비교한다면 좋을 것이다. 

* **특이값(outlier)의 존재여부**<br>
자료의 범위를 확인할 때 언급했듯이 500대에서 자료의 공백이 있고 400대의 값 하나(위의 summary를 통해 이 값이 456임을 확인했다.)가 동떨어져 있는 것을 확인할 수 있다. 한눈에 특이값의 여부를 찾을 수 있다. 전반적인 경향성을 확인하기 위해 456의 값을 특이값으로 간주하여 제외한 뒤 줄기잎그림을 다시 그릴 수 있다. 그 결과는 아래와 같다. 물론 특이값은 함부로 제거해서는 안되며 다양한 근거를 통해 신중하게 처리해야 할 것이다. 
```{r}
stem(Nile[Nile != 456])
```
<br><br>

#### **3. R의 `warpbreaks` 자료를 이용하여 wool A, B 각기 따로 breaks의 stem and leaf display 그리고 분포의 특징에 대하여 비교 설명하여라.**
R의 패키지는 분석 함수뿐 아니라 예제 데이터도 포함하는 경우가 많다. 이 데이터를 패키지 데이터셋이라고 한다. 보통 R을 시작하면 datasets라고 하는 패키지가 자동으로 로드되는데 이 패키지는 기본적인 예제 데이터셋만을 포함하고 있는 패키지이다.`warpbreaks` 데이터셋은 이 패키지에 포함되어 있기 때문에 `warpbreaks`이라는 명령어로 바로 불러올 수 있다. <br><br>
`warpbreaks` 데이터셋에 대한 설명은 `?warpbreask`라는 명령어를 통해 확인할 수 있다. 

* Description : This data set gives the number of warp breaks per loom, where a loom corresponds to a fixed length of yarn.
* Format : A data frame with 54 observations on 3 variables.
* columns <br>
[,1]	breaks : numeric	The number of breaks<br>
[,2]	wool : factor	The type of wool (A or B)<br>
[,3]	tension : factor	The level of tension (L, M, H)<br><br>

먼저, wool의 값이 A인 경우와 B인 경우인 경우를 나누어준다.  `[]`를 사용하여 각각의 경우를 기존 데이터프레임으로부터 인덱싱할 수 있으며 이를 각각 `A`와 `B`라는 변수에 저장한다. 
```{r}
A = warpbreaks[warpbreaks$wool=="A",]
B = warpbreaks[warpbreaks$wool=="B",]
```
줄기잎그림을 그리기 전에 각각의 정보에 대한 `summary`를 진행한다. 자료분석의 대상이 되는 정보는 각 자료의 `breaks`값이다. 아래의 `summary`결과에서 가장 눈에 띄는 정보는 두 자료의 최대값이 차이가 많이 난다는 점이다. A자료의 `breaks`값의 최대값은 70인 반면, B자료의 `breaks`값의 최대값은 44이다. 최소값, 제1분위수, 중앙값에서는 두 자료의 값이 크게 차이가 나지 않지만 제3분위수 이후부터 값의 차이가 발생하는 것을 확인할 수 있다.
```{r}
summary(A$breaks)
summary(B$breaks)
```
본격적으로 줄기잎그림을 그리기 전에 두 자료의 개수가 동일한지를 확인하겠다. 두 개의 줄기잎그림을 비교할 때 자료의 개수가 크게 차이난다면 비교를 올바르게 진행할 수 없다. 확인 결과 두 자료의 개수는 동일하다. 
```{r}
length(A$breaks)==length(B$breaks)
```
<br><br>
`A`와 `B`를 나누어주고 각각의 정보를 확인했으니 이제 `stem()`을 통해 각각의 줄기잎그림을 그려준다. 역시 그림의 대상이 되는 열은 `breaks`이다. 
```{r}
stem(A$breaks)
stem(B$breaks)
```
위의 두 그림을 비교하려고 했는데 자세히 살펴보니 두 그림의 줄기가 다르다. `A`의 줄기잎그림의 줄기는 1,2,3,4,5,6,7이고 `B`의 줄기잎그림의 줄기는 1,1,2,2,3,3,4이다. 줄기의 수를 줄이거나 늘림으로써 가장 보기 좋은 모양의 줄기 그림을 얻을 수 있는 것은 줄기잎그림의 큰 장점 중 하나이지만 이렇게 두 자료를 비교하기 위해서는 기준이 되는 줄기를 통일시켜줄 필요가 있다. 적절한 줄기 수를 정하는 최적 공식은 존재하지 않기 때문에 시행착오를 통해 여러 개의 줄기 그림을 그리고 자료 특성이 어떻게 다르게 보이는지를 살펴보는 것이 좋다. 
<br><br>
먼저 `B`의 줄기를 기준으로 하자. 이를 위해서는 `A`의 줄기 수를 두 배로 늘려주어야한다. <br>이 때, `scale`을 사용하여 줄기 수를 조절할 수 있다. `A`의 줄기 수를 두 배로 늘려준다. 결과는 다음과 같다.
```{r}
stem(A$breaks, scale=2)
stem(B$breaks)
```
일반적으로 줄기 수를 늘이면 늘일수록 많은 수의 봉우리를 보게 되고, 그 반대로 줄기 수를 줄이면 줄일수록 적은 수의 봉우리를 보게 된다. 위에서는 `A`의 줄기 수를 늘려서 표현했다. 두 자료의 줄기를 같게 만들어주었으므로 이제 비교가 가능하다.
<br><br>
반면 `A`의 줄기를 기준으로 하여 `B`의 줄기 수를 조절하는 방법도 가능하다. `B`의 줄기 수를 반으로 줄여준다. 결과는 다음과 같다. 
```{r}
stem(A$breaks)
stem(B$breaks, scale=0.5)
```
<br>
전자의 방식에서는 `A`의 줄기 수가 너무 많아져 자료의 공백이 불필요하게 많아지는 등 자료의 분포를 올바르게 나타내기 힘들다고 판단하여 후자의 방식으로 두 개의 자료를 비교한다. 

* **군집(cluster)의 수**<br>
`A`와 `B` 모두에서 20대에서 가장 많은 빈도가 발생했다. 20대의 값을 중심으로 하는 하나의 큰 군집으로 생각해도 좋을 것이다. 이는 두 자료 모두에서 공통으로 나타나는 현상이다.

* **대칭성 여부**<br>
두 자료 모두 대칭적인 분포라고 말하기는 어렵다. 20대의 줄기를 중심으로 자료의 분포가 이어지지만 두 자료 모두 오른쪽으로 길게 늘어진 형태의 분포를 가진다. 

* **자료의 범위 및 산포**<br>
두 자료의 범위는 상당히 다르다. 줄기의 수에서 확인할 수 있듯이 `A`의 줄기는 7까지 표현되지만 `B`의 줄기는 4에서 끊긴다. 위에서 언급했듯이 두 자료의 수는 같다. 자료의 수는 같은데 범위가 다르니 산포의 정도도 다르다. 작은 값에서의 분포는 비슷하지만 큰 값의 분포에서는 `A`의 꼬리가 훨씬 길게 늘어짐을 눈으로 확인할 수 있다.

* **특이값(outlier)의 존재여부**<br>
두 자료 모두에서 특별히 특이값이라고 생각할만한 자료의 값은 보이지 않는다.
<br>

종합하면 A유형의 wool로 만든 실이 끊어지는 횟수는 B유형의 그것보다 분산이 크다. B유형의 wool로 만든 실이 끊어지는 횟수는 10대에서 40대의 값으로 비교적 예측가능한데 비해, A유형의 wool로 만든 실이 끊어지는 횟수는 범위가 10대에서 70대로 넓어 B에 비해 예측불가능하다.
<br><br>

#### **4. R에서 Seatbelt 파일에 대한 설명은 ‘?Seatbelts’ 하면 알 수 있다.**

`Seatbelts` 데이터는 다음의 열들을 갖는 시계열자료이다. 데이터셋에 대한 설명은 `?Seatbelts`라는 명령어를 통해 확인할 수 있다.  

* [,1] DriversKilled : car drivers killed.
* [,2] drivers : same as UKDriverDeaths.
* [,3] front : front-seat passengers killed or seriously injured.
* [,4] rear : rear-seat passengers killed or seriously injured.
* [,5] kms : distance driven.
* [,6] PetrolPrice : petrol price.
* [,7] VanKilled : number of van (‘light goods vehicle’) drivers.
* [,8] law : 0/1: was the law in effect that month?
<br><br>

##### **4-1. 운전자 1000명당, 운행거리 10000km 당 사망운전사수(killed)를 계산하여라.**
위의 자료에서 사망운전자수 정보를 비교하고 싶은데 `Driverskilled`의 값을 그대로 가져다쓰면 문제가 발생한다. 운전자가 많을수록 사망운전자수는 증가할 것이다. 마찬가지로 운행거리가 증가할수록 사망운전자수도 증가할 것이다. 각 월마다 운전자수와 운행거리가 다르므로 각각의 `Driverskilled`값을 운전자 수와 운행거리에 대해 스케일링을 해주어야한다. 문제에서 제시한대로 운전자 1000명, 운행거리 10000km를 기준으로 `Driverskilled`의 조정된 값을 계산해주는 식은 다음과 같다.
$$
Driverskilled(scaled) = Driverskilled \times {1000 \over drivers} \times {10000 \over kms}
$$
위 수식을 계산하여 `killed`라는 변수에 저장한다.
```{r}
killed = Seatbelts[,1] * 1000/Seatbelts[,2] * 10000/Seatbelts[,5]
```
그런데 한가지 확인해야할 것이 있다. 위 식에서 운전자수와 운행거리에 대해 사망자수를 동시에 스케일링을 해주었는데 만약 운전자수와 운행거리가 높은 양의 상관관계를 갖는다면 이것은 중복으로 스케일링을 해준 것이 된다. 따라서 운전자수와 운행거리의 상관관계를 살펴볼 필요가 있다. 상관관계는 산점도를 통해 간단히 확인할 수 있으며 아래의 그림을 살펴보면 둘의 상관관계는 크지 않으며 눈에 띄는 선형성이 없음을 확인할 수 있다. 
```{r}
plot(Seatbelts[,2], Seatbelts[,5], main="scatterplot of drivers and kms", xlab="drivers", ylab="kms")
```

최종적으로 산출된 `killed`의 값들은 다음과 같다. 
```{r}
killed
```
<br><br>

##### **4-2. 사망운전사수의 줄기 그림을 그리고 간단히 서술하여라.**
위에서 계산된 `killed`의 분포를 한눈에 보기 위해 `stem()`으로 줄기잎그림을 그릴 수 있다. 
```{r}
summary(killed)
```
```{r}
stem(killed)
```
<br>

위의 줄기잎그림에서 줄기는 십의 자리수를, 잎은 일의 자리수를 나타낸다.

* **군집(cluster)의 수**<br>
위 그림의 주요 특징은 이봉분포의 모습을 보인다는 점이다. 이것은 자료가 2개의 군집으로 되어있음을 말한다. 40대 초반의 주 군집과 50대 후반대의 딸린 군집이 혼합된 형태를 보인다. 각 군집이 어떤 속성과 관련이 있는가를 밝혀보는 작업이 필요해 보인다. 

* **대칭성 여부**<br>
줄기잎그림을 통해 대칭성 여부를 눈으로 확인할 수 있다. 40대의 줄기에서 가장 높은 빈도를 보이고 양 극단으로 갈수록 빈도 수가 줄어드는 것을 확인할 수 있는데 오른쪽으로 길게 뻗어있는 모양이다. 하지만 위에서 언급했듯이 이봉분포의 형태를 띠고 있기 때문에 대칭적이라고 보기는 힘들다.

* **자료의 범위 및 산포**<br>
자료의 범위 및 산포 역시 쉽게 확인할 수 있다. 자료의 범위는 24부터 90까지이다.(그림에서 판단할 수 있는 자료의 범위는 24~90이지만 summary를 확인해보면 정확한 자료의 범위는 24.34~90.43이다.) 

* **특이값(outlier)의 존재여부**<br>
20대 후반의 줄기에서 자료의 공백이 있고 20 초반대의 값 하나(위의 summary를 통해 이 값이 24.34임을 확인했다.)가 동떨어져 있는 것을 확인할 수 있다. 한눈에 특이값의 여부를 찾을 수 있다. 특이값은 함부로 제거해서는 안되며 다양한 근거를 통해 신중하게 처리해야 할 것이다. 
<br><br>

##### **4-3. 안전띠 법이 시행되기 전과 후의 사망운전사수의 줄기 그림을 각각 그리고 비교하여라.**
안전띠 법의 시행여부는 8번째 열에 0과 1로 표기되어있다. 0은 시행 전, 1은 시행 후를 나타낸다. 8번째 열을 나타내면 다음과 같다. 1983년 2월부터 안전띠 법이 시행되었음을 확인할 수 있다. 우리는 이에 따른 사망운전자수를 확인해야하기 때문에 8번째 열의 자료를 통해 1번째 열의 자료를 인덱싱해주어야한다. `sum(Seatbelts[,8]==0)`을 통해 169번째까지의 값은 0, 170번째부터의 값은 1임을 확인할 수 있다. 
```{r}
Seatbelts[,8]
sum(Seatbelts[,8]==0)
sum(Seatbelts[,8]==1)
length(Seatbelts[,8])
```
안전띠 법 시행 전과 후를 나누어 각각의 다른 변수 `a`와 `b`에 저장해준다. 위에서 확인한 바와 같이 자료의 169번째까지의 값은 안전띠 법 시행 전의 자료, 170번째부터의 값은 안전띠 법 시행 이후의 자료이다. 이 정보를 활용해 다음과 같이 사망운전자수(killed)의 자료를 나누어준다. 그리고 각각의 줄기잎그림을 그려준다. 다만 자료의 수가 너무 차이가 많이 나기 때문에 안전띠 법 시행 이후의 자료에 대해서는 `scale=2`를 통해 줄기의 수를 2배로 늘려준다. 결과는 다음과 같다. 
```{r}
a = killed[1:169]
b = killed[170:192]
```
```{r}
summary(a)
summary(b)
stem(a, scale=1)
stem(b, scale=2)
```
위의 두 줄기잎그림을 살펴보면 일단 두 자료의 수가 굉장히 차이가 많이 남을 확인할 수 있다. 따라서 절대적인 기둥의 높이를 살피기보다는 자료의 분포와 모양으로 비교를 해야한다. 먼저 각각의 최대최소값을 비교해보자. 최대값이 전자에서는 90, 후자에서는 58임을 확인할 수 있다. 최소값은 각각 34, 24이다. 즉 안전띠 법 시행 이전의 사망자수 범위는 34~90이며 시행 이후의 사망자수의 범위는 24~58이다. 이를 통해 안전띠 법 시행 이후의 사망운전자수 분포가 전체적으로 왼쪽으로(사망자수가 적은 쪽으로) 이동하였음을 알 수 있다. 이는 법의 시행이 사망자 수 감소에 긍정적인 영향을 미쳤음을 시사한다. 후자의 분포에는 20대 후반과 50대 초반에서 자료의 공백이 발생했다. 하지만 이는 절대적인 자료의 수가 부족해서 발생한 것으로 추정된다. 대칭성 여부 역시 후자의 경우 자료의 수가 늘어난다면 대칭성을 띨 것으로 예상된다. 이를 통해 안전띠 법의 시행이 60이상의 다수의 사망자 발생을 방지하는 효과가 발생할 것으로 기대된다. 보다 정확한 비교를 위해서는 안전띠 법 시행 이후의 사망운전자수 데이터가 더 많이 수집되어야 한다. 
<br><br>

#### **5. 줄기그림과 히스토그램의 차이, 장단점 등을 간단히 표로 작성하여라. 강의노트, 책, 허명회 교수의 R 프로젝트 파일 참조.**
아래는 4-2번 문제의 사망운전자수에 대해 줄기잎그림과 히스토그램을 각각 그린 것이다. 적절한 조정을 통해 줄기잎그림의 줄기와 히스토그램의 구간을 맞춰주었다. 

```{r, echo=FALSE}
stem(killed)
hist(killed, nclass=14, main="Hist of Killed", xlab="Killed", xlim=c(20,100))
```
<br><br>

||줄기잎그림과 히스토그램|
|:---:|:---:|
|공통점| 그림의 테두리가 동일하다. <br> 각 구간의 관측 빈도에 비례하는 길이의 기둥을 가진다.|
<br><br>

||줄기잎그림|히스토그램|
|:---:|:---:|:---:|
|차이점|구간 내의 자료들이 각각 숫자로 표기되어 있다.|단일 길이의 상자가 쌓인 형태로 표현된다.|
||작성된 줄기그림만으로 줄기수 변경이 가능하다.|구간의 변경에 원자료가 필요하다.|
||구간 폭을 임의로 정할 수 없다.|구간의 폭을 임의로 정할 수 있다.|
<br><br>

||줄기잎그림|히스토그램|
|:---:|:---:|:---:|
|장점|통계적 정보의 손실이 적다.<br>구간 폭 변경이 쉽다.|구간 폭의 설정이 자유롭다.|
|단점|구간 폭 설정에 제약이 있다. |통계적 정보의 손실이 크다.<br>구간 폭 변경이 어렵다.|
<br><br>

결론적으로 크기 100~200 이내의 자료를 수작업으로 처리하는 경우 줄기잎그림이 히스토그램에 비해 효율적인 분포도를 제공한다. 그러나 자료수가 커지면 히스토그램이 보기에 나은 그래프를 제공한다.

<br>

-------------------------------------------------------------------------------------------
### R Script
보고서에 쓰인 모든 코드를 아래에 정리해두었다.
```{r, eval=FALSE}

## R script

#2.
Nile
summary(Nile)
stem(Nile)
stem(Nile[Nile != 456])

#3.
head(warpbreaks)
A = warpbreaks[warpbreaks$wool=="A",]
B = warpbreaks[warpbreaks$wool=="B",]
summary(A$breaks)
summary(B$breaks)
length(A$breaks)==length(B$breaks)
stem(A$breaks)
stem(B$breaks)
stem(A$breaks, scale=2)
stem(B$breaks)
stem(A$breaks)
stem(B$breaks, scale=0.5)

#4.

#4.1.
killed = Seatbelts[,1] * 1000/Seatbelts[,2] * 10000/Seatbelts[,5]
plot(Seatbelts[,2], Seatbelts[,5], main="scatterplot of drivers and kms", xlab="drivers", ylab="kms")
killed

#4.2.
summary(killed)
stem(killed)

#4.3.
Seatbelts[,8]
sum(Seatbelts[,8]==0)
sum(Seatbelts[,8]==1)
length(Seatbelts[,8])
a = killed[1:169]
b = killed[170:192]
summary(a)
summary(b)
stem(a, scale=1)
stem(b, scale=2)

#5.
stem(killed)
hist(killed, nclass=14, main="Hist of Killed", xlab="Killed", xlim=c(20,100))


```